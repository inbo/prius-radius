```{r load-packages}
library(sf)
library(tidyverse) 
library(httr)
library(ows4R) 
library(leaflet)
library(gdalUtilities)
library(ggplot2)
library(n2khab)
library(units)
```

```{r clear-memory}
rm(list=ls())
```

```{r function-multisurface-to-multipolygon}
ensure_multipolygons <- function(X) {
    tmp1 <- tempfile(fileext = ".gpkg")
    tmp2 <- tempfile(fileext = ".gpkg")
    st_write(X, tmp1)
    ogr2ogr(tmp1, tmp2, f = "GPKG", nlt = "MULTIPOLYGON")
    Y <- st_read(tmp2)
    st_sf(st_drop_geometry(X), geom = st_geometry(Y))
}
```

# Read data into R

```{r import-species-list}
species_list <- read_csv("./radius/data/input/radius_species_list.csv") 
```

```{r import-species-occ}
occ_flanders <- read_csv("./radius/data/input/gbif_occ_flanders.csv") %>%
  left_join(species_list, by = c("speciesKey" = "GBIF_code", "Soort")) %>%
  select(year, decimalLongitude, decimalLatitude, speciesKey, Soort, coordinateUncertaintyInMeters) %>%
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), crs = "+proj=longlat +datum=WGS84") %>%
  st_transform(31370) # st_buffer()/st_union does not correctly buffer longitude-latitude spatial data, whose distance is assumed to be in decimal degrees (arc_degrees).We transform the EPSG:4326 to Lambert 72.
```

```{r import-toewijzing-soorten-en-habitats}
toewijzing_soorten <- read_csv2("./radius/data/input/toewijzing_soorten.csv")
toewijzing_habitats <- read_csv2("./radius/data/input/toewijzing_habitats.csv", col_types = cols(code = col_character()))
```


```{r boundaries-flanders}
Vlaanderen_grenzen <- st_read("./prius/data/spatial/flanders_wgs84.geojson")
Provincies_grenzen <- st_read("./prius/data/spatial/Provincies.geojson")
```

# Habitatrichtlijndeelgebieden (ps:ps_hbtrl_deel)

```{r get-ps-hbtrl-deel}
wfs_ANB <- "https://www.mercator.vlaanderen.be/raadpleegdienstenmercatorpubliek/wfs"

#generate URL for WFS download
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "ps:ps_hbtrl_deel")
request <- build_url(url)

ps_hbtrl_deel <- read_sf(request) %>%
  st_set_crs(31370) %>%  # omzetten naar Lambert72
  ensure_multipolygons()   # multisurface to multipolygon

st_write(ps_hbtrl_deel, "./radius/data/spatial/ps_hbtrl_deel.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = ps_hbtrl_deel, aes(color = gebcode))
```

# Vogelrichtlijngebieden (ps:ps_vglrl)

```{r get-ps-vgrl}
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "ps:ps_vglrl")
request <- build_url(url)

ps_vglrl <- read_sf(request) %>%
  st_set_crs(31370) %>%  
  ensure_multipolygons()  

st_write(ps_vglrl, "./radius/data/spatial/ps_vglrl.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = ps_vglrl, aes(color = na2000code))
```

# Natura 2000 Habitatkaart

# Toon en Floris hebben een gestandaardiseerde versie van de BWK/N2000 habitatkaart gemaakt waarin uitsluitend N2000 habitattypes en rbbs worden weergegeven (https://zenodo.org/records/3355193). Hierbij hoort ook de package n2khab voor efficiënt gebruik. 
```{r import-habitatmap_stdized}
# fileman_folders(root = "git", path = "./radius/data/spatial")

# load processed habitatdata
hms <- read_habitatmap_stdized("./radius/data/spatial/n2khab_data/20_processed/habitatmap_stdized.gpkg")

hms_pol <- hms$habitatmap_polygons 

hms_types <- hms$habitatmap_types 

# processing: we filteren uitsluitend N2000 habitattypes (weglaten: rbb)
n2khab <- hms_pol %>%
  inner_join(hms_types, by = "polygon_id") %>%  # hms_types en hms_pol samenvoegen
  filter(grepl('^[0-9]', type)) %>%   # we gebruiken uitsluitend de n2000 habitattypes (beginnen met cijfer 0-9, niet de rbbs)
  mutate(type = substr(type, 1, 4)) %>% # only select type codes, remove subtypes
  mutate(area = st_area(.)) %>%
  mutate(area_type = area * phab / 100) %>% # calculate area of type within polygon (vb. polygon met opp 100 m² waarvan phab 9120 = 30% --> oppervlak van 9120 in dat polygon = 100 m² * 0.3 = 30 m²) %>%
  group_by(type) %>%
  summarise(area_type = sum(area_type) %>%  
              set_units("ha") %>%
              round(2),
            area = sum(area) %>%
              set_units("ha") %>%
              round(2))

# naam van habitattypes toevoegen
hab_names <- read_namelist(lang = "nl")  %>%
  filter(grepl('^[0-9]', code))

n2khab <- n2khab %>%
  left_join(read_namelist(lang = "nl"), by = c("type" = "code"))

st_write(n2khab, "./radius/data/spatial/n2khab.shp")
```

```{r}
ggplot() + 
  geom_sf(data = Provincies_grenzen) +
  geom_sf(data = n2khab, aes(color = type))
```

# ANB Patrimonium databank (am:am_patdat)

```{r ANB patrimonium databank (am:am_patdat)}
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "am:am_patdat")
request <- build_url(url)

am_patdat <- read_sf(request) %>%
  st_set_crs(31370) %>%  
  ensure_multipolygons()   

st_write(am_patdat, "./radius/data/spatial/am_patdat.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = am_patdat, aes(color = regio))
# Oppassen : er (b)lijken enkel NA's onder regio te zitten?
```

# Natuurbeheerplannen (ps:ps_nbhp)

```{r get-ps-nbhp}
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "ps:ps_nbhp")
request <- build_url(url)

ps_nbhp <- read_sf(request) %>%
  st_set_crs(31370) %>%  
  ensure_multipolygons()   

st_write(ps_nbhp, "./radius/data/spatial/ps_nbhp.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = ps_nbhp)
```

# Add columns with abbreviations
```{r add-abbreviations-patdat}
am_patdat <- am_patdat %>%
  mutate(rechtenanb_abb = case_when(
    rechtenanb == "Technisch beheer conform bosdecreet" ~ "Bosdec",
    rechtenanb == "Eigendom" ~ "Eigend",
    rechtenanb == "Huur" ~ "Huur",
    rechtenanb == "Beheerovereenkomst" ~ "BehOve",
    rechtenanb == "Protocol landsverdediging" ~ "ProLan",
    rechtenanb == "Erfpacht" ~ "Erfpac")) %>%
  mutate(regio_abb = case_when(
    regio == "Antwerpse Kempen" ~ "AntKem",
    regio == "Hoge Kempen tot Voeren" ~ "HKeVoe",
    regio == "Groene Gordels" ~ "GroGor",
    regio == "Brabantse Wouden" ~ "BraWou",
    regio == "Demerland & Zuiderkempen" ~ "DemZKe",
    regio == "Vlaamse Ardennen & Schelde-Leie" ~ "VArSch",
    regio == "Kust & Westhoek" ~ "KusWes",
    regio == "Taxandria" ~ "Taxand",
    regio == "Lage tot aan Hoge Kempen" ~ "LtHKem",
    regio == "Zandig Vlaanderen" ~ "ZanVla"
  ))
```

```{r add-abbreviations-nbhp}
ps_nbhp <- ps_nbhp %>%
  mutate(natuurbeheerplantype_abb = case_when(
    natuurbeheerplantype == "Natuurbeheerplan Type 1" ~ "Type1",
    natuurbeheerplantype == "Natuurbeheerplan Type 2" ~ "Type2",
    natuurbeheerplantype == "Natuurbeheerplan Type 3" ~ "Type3",
    natuurbeheerplantype == "Natuurbeheerplan Type 4" ~ "Type4",
    natuurbeheerplantype == "Uitgebreid Bosbeheerplan" ~ "BosbeU",
    natuurbeheerplantype == "Beheerplan Militair domein" ~ "MilDom",
    natuurbeheerplantype == "Vlaams Natuurreservaat" ~ "VNatre",
    natuurbeheerplantype == "Aangewezen Bosreservaat" ~ "BosreA",
    natuurbeheerplantype == "Harmonisch Park- en Groenbeheerplan" ~ "HarmPG",
    natuurbeheerplantype == "Erkend Natuurreservaat" ~ "Natres",
    natuurbeheerplantype == "Erkend Bosreservaat" ~ "BosreE")) %>%
  mutate(eigendomtype_abb = case_when(
    eigendomtype == "Natuurlijke persoon" ~ "NatPer",
    eigendomtype == "Privaatrechtelijke rechtspersoon" ~ "PrivRec",
    eigendomtype == "Agentschap voor Natuur en Bos" ~ "VOANB",
    eigendomtype == "Bestuur" ~ "Bestuur",
    eigendomtype == "Andere Vlaamse overheid" ~ "VOander",
    eigendomtype == "Andere" ~ "Andere"
  ))
```

# Calculating occupancy metrics
```{r calculate-occupancy-metrics, warning=FALSE}
# list wfs-maps
list.dfs <- list(
  HBTRL = ps_hbtrl_deel,
  VGLRL = ps_vglrl,
  N2KHAB = n2khab,
  PATDAT = am_patdat,
  NBHP = ps_nbhp,
  TOP3 = data.frame(), 
  N2KHAB_SUB = data.frame()
)

# initialize a list for results
list.results <- lapply(list.dfs, function(x) data.frame())

# loop through unique species
for (i in unique(occ_flanders$Soort)) {
  print(i)
  
  # in welk milieu komt de soort voor (marien, brak, zoetwater, terrestrisch)
  soort_milieu <- names(toewijzing_soorten)[toewijzing_soorten[toewijzing_soorten$soort == i, ] == 1]
  
  # subset van n2k habitattypes obv milieu waarin de soort voorkomt (soort_milieu)
  n2khab_subset <- toewijzing_habitats %>%
    select(code, soort_milieu) %>%
    filter_at(vars(soort_milieu), any_vars(. == 1)) %>%
    pull(code)
  
  
  # extract species occurrence
  occ_species <- occ_flanders[occ_flanders$Soort == i,]
  
  # add buffer around species occurrences + union
  occ_species_buf <- occ_species %>%
    st_buffer(dist = 100) %>%
    st_union() %>% 
    st_cast('POLYGON') %>% 
    st_sf() %>%
    mutate(buf_area = st_area(.))
  
  total_area <- sum(occ_species_buf$buf_area)
  
  # loop through wfs-maps to calculate occupancy metrics
  for (j in seq_along(list.dfs[1:5])) {
    
    # transform CRS to Lambert 72 to use st_buffer with meters instead of decimal degrees
    gebied <- list.dfs[[j]] %>%
      st_transform(31370) %>%
      mutate(geb_area = st_area(.))
    
    gebied_summary <- gebied %>%
      st_drop_geometry() %>%
      select(code = if (j == 1) "gebcode" else if (j == 2) "na2000code" else if (j == 3) "type" else if (j == 4) "regio_abb" else "eigendomtype_abb", geb_area) %>%
      group_by(code) %>%
      summarise(geb_area = sum(geb_area))
    
    # intersection buffered occurrences with wfs-map
    occ_species_intersection <- occ_species_buf %>%
      st_intersection(gebied) %>% 
      mutate(intersect_area = st_area(.)) 
    
    overlap_intersection <- sum(occ_species_intersection$intersect_area)
    percentage_overlap_in <- as.numeric(overlap_intersection / total_area)
    percentage_overlap_of <- as.numeric(overlap_intersection / sum(gebied$geb_area))
    
    if (nrow(occ_species_intersection) != 0) {  # skip following steps if there's no overlap 
      # Standard occupancy metrics across all wfs-maps
      metrics_df <- data.frame(
        Soort = i,
        Gebied = paste0(c("in", "of"), names(list.dfs)[j]),
        Overlap = format(round(c(percentage_overlap_in, percentage_overlap_of), 6), scientific = FALSE))
      
      list.results[[j]] <- rbind(list.results[[j]], metrics_df)
      
      # additional occupancy metrics for HBTRL (i = 1), VGLRL (i = 2), N2KHAB (i = 3)
      if (j %in% c(1, 2, 3)) {
        
        # overlap percentage per gebied 
        overlap_per_gebied <- occ_species_intersection %>%
          group_by(code = if (j == 2) na2000code else if (j == 3) type else gebcode) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          st_drop_geometry() %>%
          inner_join(gebied_summary, by = "code")
        
        
        for (row in 1:nrow(overlap_per_gebied)) {
          # OPTIE 1: percentage van overlap dat in bepaald gebied valt
          # percentage_overlap_in = as.numeric(overlap_per_gebied[row,]$intersect_area / overlap_intersection)
          # OPTIE 2: percentage van totale verspreiding dat in bepaald gebied valt
          percentage_overlap_in = as.numeric(overlap_per_gebied[row,]$intersect_area / total_area)
          
          # percentage van oppervlakte HBTRL/VLRL/BWKHAB gebied dat overlapt met soortverspreiding
          percentage_overlap_of = as.numeric(overlap_per_gebied[row,]$intersect_area / overlap_per_gebied[row,]$geb_area)
          
          metrics_df <- data.frame(
            Soort = i,
            Gebied = paste0(c("in", "of"), as.character(overlap_per_gebied[row,1])),
            Overlap = format(round(c(percentage_overlap_in, percentage_overlap_of), 6), scientific = FALSE)
          )
          
          list.results[[j]] <- rbind(list.results[[j]], metrics_df)
        }
        
        if (j == 3) {
          overlap_n2khab_subset <- overlap_per_gebied %>%
            filter(code %in% n2khab_subset)
          
          if (nrow(overlap_n2khab_subset) != 0) {
            
            for (row in 1:nrow(overlap_n2khab_subset)) {
              # OPTIE 1: percentage van overlap dat in bepaald gebied valt
              # percentage_overlap_in = as.numeric(overlap_per_gebied[row,]$intersect_area / overlap_intersection)
              # OPTIE 2: percentage van totale verspreiding dat in bepaald gebied valt
              percentage_overlap_in = as.numeric(overlap_n2khab_subset[row,]$intersect_area / total_area)
              
              # percentage van oppervlakte HBTRL/VLRL/BWKHAB gebied dat overlapt met soortverspreiding
              percentage_overlap_of = as.numeric(overlap_n2khab_subset[row,]$intersect_area / overlap_n2khab_subset[row,]$geb_area)
              
              metrics_df <- data.frame(
                Soort = i,
                Gebied = paste0(c("in", "of"), as.character(overlap_n2khab_subset[row,1])),
                Overlap = format(round(c(percentage_overlap_in, percentage_overlap_of), 6), scientific = FALSE)
              )
              
              list.results[[7]] <- rbind(list.results[[7]], metrics_df)
            }
          }
        }
      }
      
      # additional occupancy metrics for PATDAT (i = 4)
      if (j == 4) {
        
        # totaal aantal domeinen waarmee verspreiding overlapt
        list.results[[j]] <- rbind(list.results[[j]], data.frame(
          Soort = i,
          Gebied = "nDomeinen",
          Overlap = length(unique(occ_species_intersection$id))))
        
        # aantal bezette domeinen per type recht anb
        anb_rechten <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(id, rechtenanb, rechtenanb_abb) %>%
          unique() %>%
          group_by(rechtenanb_abb) %>%
          summarise(n = n()) 
        
        for (row in 1:nrow(anb_rechten)) {
          list.results[[j]] <- rbind(list.results[[j]], data.frame(
            Soort = i,
            Gebied = paste0("n", as.character(anb_rechten[row,1])),
            Overlap = as.character(anb_rechten[row,2])))
        }
        
        # percentage overlap per anb regio
        overlap_per_anb_regio <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(regio_abb, intersect_area) %>%
          unique() %>%
          group_by(regio_abb) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          arrange() %>%
          inner_join(gebied_summary, by = c("regio_abb" = "code"))
        
        for (row in 1: nrow(overlap_per_anb_regio)) {
          # OPTIE 1: percentage van overlap met PATDAT per anb regio
          #percentage_overlap_in = as.numeric(overlap_per_anb_regio[row,]$intersect_area / overlap_intersection)
          # OPTIE 2: percentage van totale verspreiding dat overlapt per anb regio
          percentage_overlap_in = as.numeric(overlap_per_anb_regio[row,]$intersect_area / total_area)
          
          percentage_overlap_of = as.numeric(overlap_per_anb_regio[row,]$intersect_area / overlap_per_anb_regio[row,]$geb_area)
          
          metrics_df <- data.frame(
            Soort = i,
            Gebied = paste0(c("in", "of"), as.character(overlap_per_anb_regio[row,1])),
            Overlap = format(round(c(percentage_overlap_in, percentage_overlap_of), 6), scientific = FALSE)
          )
          
          list.results[[j]] <- rbind(list.results[[j]], metrics_df)
        }
      }
      
      # additional occupancy metrics for NBHP (i = 5)
      if (j == 5) {
        
        # totaal aantal gebieden waarmee verspreiding overlapt
        list.results[[j]] <- rbind(list.results[[j]], data.frame(
          Soort = i,
          Gebied = "nNBHP",
          Overlap = length(unique(occ_species_intersection$id))))
        
        # aantal bezette domeinen per type natuurbeheerplan
        n_per_beheerplantype <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(id, natuurbeheerplantype, natuurbeheerplantype_abb) %>%
          unique() %>%
          group_by(natuurbeheerplantype_abb) %>%
          summarise(n = n())
        
        for (row in 1:nrow(n_per_beheerplantype)) {
          list.results[[j]] <- rbind(list.results[[j]], data.frame(
            Soort = i,
            Gebied = paste0("n", as.character(n_per_beheerplantype[row,1])),
            Overlap = as.character(n_per_beheerplantype[row,2])))
        }
        
        # percentage overlap per eigendomtype
        overlap_per_eigendomtype <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(eigendomtype_abb, intersect_area) %>%
          unique() %>%
          group_by(eigendomtype_abb) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          arrange() %>%
          inner_join(gebied_summary, by = c("eigendomtype_abb" = "code"))
        
        for (row in 1: nrow(overlap_per_eigendomtype)) {
          # OPTIE 1: percentage van overlap met NBHP dat overlapt per eigendomtype
          # percentage_overlap_in = as.numeric(overlap_per_eigendomtype[row,]$intersect_area / overlap_intersection)
          # OPTIE 2: percentage van totale verspreiding dat overlapt per eigendomtype
          percentage_overlap_in = as.numeric(overlap_per_eigendomtype[row,]$intersect_area / total_area)
          
          list.results[[j]] <- rbind(list.results[[j]], data.frame(
            Soort = i,
            Gebied = paste0("in", as.character(overlap_per_eigendomtype[row,1])),
            Overlap = format(round(percentage_overlap_in, 6), scientific = FALSE)))
        } 
      }
      
      # Top 3 gebieden voor HBTRL, VGLRL, NBHP
      if (j %in% c(1,2,5)) {
        top_3 <- occ_species_intersection %>%
          group_by(naam = if (j == 2) gebnaam else if (j == 5) naamdossier else naam) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          slice_max(order_by = intersect_area, n = 3, na_rm = TRUE) %>%
          st_drop_geometry()
        
        for (row in 1:nrow(top_3)) {
          list.results[[6]] <- rbind(list.results[[6]], data.frame(
            Soort = i,
            Gebied = paste0(names(list.dfs)[j], row),
            Overlap = as.character(top_3[row,1])))
        }
      }
      
      # Top 3 anb regio's en domeinen
      if (j == 4) {
        top_3_regio <- occ_species_intersection %>%
          group_by(regio) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          slice_max(order_by = intersect_area, n = 3, na_rm = TRUE) %>%
          st_drop_geometry()
        
        for (row in 1:nrow(top_3_regio)) {
          list.results[[6]] <- rbind(list.results[[6]], data.frame(
            Soort = i,
            Gebied = paste0(names(list.dfs)[j], "regio", row),
            Overlap = as.character(top_3_regio[row,1])))
        }
        
        top_3_domein <- occ_species_intersection %>%
          group_by(domeinnaam) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          slice_max(order_by = intersect_area, n = 3, na_rm = TRUE) %>%
          st_drop_geometry()
        
        for (row in 1:nrow(top_3_domein)) {
          list.results[[6]] <- rbind(list.results[[6]], data.frame(
            Soort = i,
            Gebied = paste0(names(list.dfs)[j], "domein", row),
            Overlap = as.character(top_3_domein[row,1])))
        }
      }
    }
    
    else {  # create empty row if there's no overlap 
      metrics_df <- data.frame(
        Soort = i,
        Gebied = paste0(c("in", "of"), names(list.dfs)[j]),
        Overlap = 0)
      
      list.results[[j]] <- rbind(list.results[[j]], metrics_df)
    }
  }    
}
```

# Adjust column format from long to wide
```{r column-format-long-to-wide}
HBTRL <- list.results$HBTRL %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, contains("in"), contains("of"))

VGLRL <- list.results$VGLRL %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, contains("in"), contains("of"))

N2KHAB <- list.results$N2KHAB %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, contains("in"), contains("of"))

PATDAT <- list.results$PATDAT %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, starts_with("n"), starts_with("in"), starts_with("of"))

NBHP <- list.results$NBHP %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, starts_with("n"), starts_with("in"))

TOP3 <- list.results$TOP3 %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "-")

N2KHAB_SUB <- list.results$N2KHAB_SUB %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, contains("in"), contains("of"))
```

```{r save-list-results-as-RData-file}
saveRDS(list.results, file="./radius/data/output/list_results.RData")
```

```{r save-separate-dfs-as-csv}
write_csv(HBTRL, "./radius/data/output/HBTRL.csv")
write_csv(VGLRL, "./radius/data/output/VGLRL.csv")
write_csv(N2KHAB, "./radius/data/output/N2KHAB.csv")
write_csv(N2KHAB_SUB, "./radius/data/output/N2KHAB_SUB.csv")
write_csv(PATDAT, "./radius/data/output/PATDAT.csv")
write_csv(NBHP, "./radius/data/output/NBHP.csv")
write_csv(TOP3, "./radius/data/output/TOP3.csv")
```