```{r load-packages}
library(sf)
library(tidyverse) 
library(httr)
library(ows4R) 
library(leaflet)
library(gdalUtilities)
library(ggplot2)
```

```{r clear-memory}
rm(list=ls())
```

```{r function-multisurface-to-multipolygon}
ensure_multipolygons <- function(X) {
    tmp1 <- tempfile(fileext = ".gpkg")
    tmp2 <- tempfile(fileext = ".gpkg")
    st_write(X, tmp1)
    ogr2ogr(tmp1, tmp2, f = "GPKG", nlt = "MULTIPOLYGON")
    Y <- st_read(tmp2)
    st_sf(st_drop_geometry(X), geom = st_geometry(Y))
}
```

# Read data into R

```{r import-species-list}
species_list <- read_csv("./radius/data/input/radius_species_list.csv") %>%
  mutate(disp_dist = 250) # Manually set dispersal distance for species (placeholder for replacement with biologically relevant distances)
```

```{r import-species-occ}
occ_flanders <- read_csv("./radius/data/input/gbif_occ_flanders.csv") %>%
  left_join(species_list, by = c("speciesKey" = "GBIF_code", "Soort")) %>%
  select(year, decimalLongitude, decimalLatitude, speciesKey, Soort, coordinateUncertaintyInMeters, disp_dist) %>%
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), crs = "+proj=longlat +datum=WGS84") %>%
  st_transform(31370)  # st_buffer()/st_union does not correctly buffer longitude-latitude spatial data, whose distance is assumed to be in decimal degrees (arc_degrees).We transform the EPSG:4326 to Lambert 72.

```

```{r boundaries-flanders}
Vlaanderen_grenzen <- st_read("./prius/data/spatial/flanders_wgs84.geojson")
Provincies_grenzen <- st_read("./prius/data/spatial/Provincies.geojson")
```

# Habitatrichtlijndeelgebieden (ps:ps_hbtrl_deel)

```{r get-ps-hbtrl-deel}
wfs_ANB <- "https://www.mercator.vlaanderen.be/raadpleegdienstenmercatorpubliek/wfs"

#generate URL for WFS download
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "ps:ps_hbtrl_deel")
request <- build_url(url)

ps_hbtrl_deel <- read_sf(request) %>%
  st_set_crs(31370) %>%  # omzetten naar Lambert72
  ensure_multipolygons()   # multisurface to multipolygon

st_write(ps_hbtrl_deel, "./radius/data/spatial/ps_hbtrl_deel.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = ps_hbtrl_deel, aes(color = gebcode))
```

# Vogelrichtlijngebieden (ps:ps_vglrl)

```{r get-ps-vgrl}
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "ps:ps_vglrl")
request <- build_url(url)

ps_vglrl <- read_sf(request) %>%
  st_set_crs(31370) %>%  
  ensure_multipolygons()   

st_write(ps_vglrl, "./radius/data/spatial/ps_vglrl.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = ps_vglrl, aes(color = na2000code))
```

# Biologische waarderingskaart (BWK:Bwkhab)

## wegens max.van 10.000 features bij inladen WFS,laadt ik de BWK/Natura2000 Habitatkaart in als shapefile

```{r import-shapefile-bwkhab}
bwkhab <- st_read("./radius/data/spatial/BwkHab.shp") %>%
  st_transform(31370)

# aanpassing bwk/n2000 habitatkaart voor gebruik in RadIUS
bwkhab_adj <- bwkhab %>% 
  mutate(HAB1 = str_sub(bwkhab$HAB1, 1, 4)) %>%  # only retain the first part of the HAB1 string
  group_by(HAB1) %>%                             # summarise df to retain one line per HAB1 value
  summarise() %>%                                    
  filter(grepl('^[0-9]', HAB1))                  # remove non-n2000 habitats

st_write(bwkhab_adj, "./radius/data/spatial/bwkhab_adj.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = bwkhab_adj)
```

# ANB Patrimonium databank (am:am_patdat)

```{r ANB patrimonium databank (am:am_patdat)}
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "am:am_patdat")
request <- build_url(url)

am_patdat <- read_sf(request) %>%
  st_set_crs(31370) %>%  
  ensure_multipolygons()   

st_write(am_patdat, "./radius/data/spatial/am_patdat.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = am_patdat, aes(color = regio))
# Oppassen : er (b)lijken enkel NA's onder regio te zitten?
```

# Natuurbeheerplannen (ps:ps_nbhp)

```{r get-ps-nbhp}
url <- parse_url(wfs_ANB)
url$query <- list(service = "WFS",
                  version = "2.0.0", 
                  request = "GetFeature",
                  typename = "ps:ps_nbhp")
request <- build_url(url)

ps_nbhp <- read_sf(request) %>%
  st_set_crs(31370) %>%  
  ensure_multipolygons()

st_write(ps_nbhp, "./radius/data/spatial/ps_nbhp.shp")
```

```{r quick-visual-check}
ggplot() + geom_sf(data = ps_nbhp)
```

# Add columns with abbreviations
```{r add-abbreviations-patdat}
am_patdat <- am_patdat %>%
  mutate(rechtenanb_abb = case_when(
    rechtenanb == "Technisch beheer conform bosdecreet" ~ "Bosdec",
    rechtenanb == "Eigendom" ~ "Eigend",
    rechtenanb == "Huur" ~ "Huur",
    rechtenanb == "Beheerovereenkomst" ~ "BehOve",
    rechtenanb == "Protocol landsverdediging" ~ "ProLan",
    rechtenanb == "Erfpacht" ~ "Erfpac")) %>%
  mutate(regio_abb = case_when(
    regio == "Antwerpse Kempen" ~ "AntKem",
    regio == "Hoge Kempen tot Voeren" ~ "HKeVoe",
    regio == "Groene Gordels" ~ "GroGor",
    regio == "Brabantse Wouden" ~ "BraWou",
    regio == "Demerland & Zuiderkempen" ~ "DemZKe",
    regio == "Vlaamse Ardennen & Schelde-Leie" ~ "VArSch",
    regio == "Kust & Westhoek" ~ "KusWes",
    regio == "Taxandria" ~ "Taxand",
    regio == "Lage tot aan Hoge Kempen" ~ "LtHKem",
    regio == "Zandig Vlaanderen" ~ "ZanVla"
  ))
```

```{r add-abbreviations-nbhp}
ps_nbhp <- ps_nbhp %>%
  mutate(natuurbeheerplantype_abb = case_when(
    natuurbeheerplantype == "Natuurbeheerplan Type 1" ~ "Type1",
    natuurbeheerplantype == "Natuurbeheerplan Type 2" ~ "Type2",
    natuurbeheerplantype == "Natuurbeheerplan Type 3" ~ "Type3",
    natuurbeheerplantype == "Natuurbeheerplan Type 4" ~ "Type4",
    natuurbeheerplantype == "Uitgebreid Bosbeheerplan" ~ "BosbeU",
    natuurbeheerplantype == "Beheerplan Militair domein" ~ "MilDom",
    natuurbeheerplantype == "Vlaams Natuurreservaat" ~ "VNatre",
    natuurbeheerplantype == "Aangewezen Bosreservaat" ~ "BosreA",
    natuurbeheerplantype == "Harmonisch Park- en Groenbeheerplan" ~ "HarmPG",
    natuurbeheerplantype == "Erkend Natuurreservaat" ~ "Natres",
    natuurbeheerplantype == "Erkend Bosreservaat" ~ "BosreE")) %>%
  mutate(eigendomtype_abb = case_when(
    eigendomtype == "Natuurlijke persoon" ~ "NatPer",
    eigendomtype == "Privaatrechtelijke rechtspersoon" ~ "PrivRec",
    eigendomtype == "Agentschap voor Natuur en Bos" ~ "VOANB",
    eigendomtype == "Bestuur" ~ "Bestuur",
    eigendomtype == "Andere Vlaamse overheid" ~ "VOander",
    eigendomtype == "Andere" ~ "Andere"
  ))
```


# Calculating occupancy metrics in protected areas
```{r calculate-occupancy-metrics, warning=FALSE}
# list wfs-maps
list.dfs <- list(
  HBTRL = ps_hbtrl_deel,
  VGLRL = ps_vglrl,
  BWKHAB = bwkhab_adj,
  PATDAT = am_patdat,
  NBHP = ps_nbhp,
  TOP3 = data.frame()
)

# initialize a list for results
list.results <- lapply(list.dfs, function(x) data.frame())

# loop through unique species
for (soort in unique(occ_flanders$Soort)) {
  print(soort)
  
  # extract species occurrence
  occ_species <- occ_flanders[occ_flanders$Soort == soort,]

  # add buffer around species occurrences based on dispersal distance + union
  occ_species_buf <- occ_species %>%
    st_buffer(dist = unique(occ_species$disp_dist)) %>%
    st_union() %>% 
    st_cast('POLYGON') %>% 
    st_sf() %>%
    mutate(buf_area = st_area(.))
  
  total_area <- sum(occ_species_buf$buf_area)
  
  # loop through wfs-maps to calculate occupancy metrics
  for (i in seq_along(list.dfs[1:5])) {
    
    # transform CRS to Lambert 72 to use st_buffer with meters instead of decimal degrees
    gebied <- list.dfs[[i]] %>%
      st_transform(31370) %>%
      mutate(geb_area = st_area(.))
    
    gebied_summary <- gebied %>%
      st_drop_geometry() %>%
      select(code = if (i == 1) "gebcode" else if (i == 2) "na2000code" else if (i == 3) "HAB1" else if (i == 4) "regio_abb" else "eigendomtype_abb", geb_area) %>%
      group_by(code) %>%
      summarise(geb_area = sum(geb_area))
    
    # intersection buffered occurrences with wfs-map
    occ_species_intersection <- occ_species_buf %>%
      st_intersection(gebied) %>% 
      mutate(intersect_area = st_area(.)) 
    
    overlap_intersection <- sum(occ_species_intersection$intersect_area)
    percentage_overlap_in <- as.numeric(overlap_intersection / total_area)
    percentage_overlap_of <- as.numeric(overlap_intersection / sum(gebied$geb_area))
    
    if (nrow(occ_species_intersection) != 0) {  # skip following steps if there's no overlap 
      # Standard occupancy metrics across all wfs-maps
      metrics_df <- data.frame(
        Soort = soort,
        Gebied = paste0(c("in", "of"), names(list.dfs)[i]),
        Overlap = format(round(c(percentage_overlap_in, percentage_overlap_of), 3)))
      
      list.results[[i]] <- rbind(list.results[[i]], metrics_df)
    
      # Additional occupancy metrics for specific cases (HBTRL (i = 1), VGLRL (i = 2), BWKHAB (i = 3))
      if (i %in% c(1, 2, 3)) {
        
        # overlap percentage per gebied 
        overlap_per_gebied <- occ_species_intersection %>%
          group_by(code = if (i == 2) na2000code else if (i == 3) HAB1 else gebcode) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          st_drop_geometry() %>%
          inner_join(gebied_summary, by = "code")
        
        
        for (row in 1:nrow(overlap_per_gebied)) {
          # OPTIE 1: percentage van overlap dat in bepaald gebied valt
          percentage_overlap_in = as.numeric(overlap_per_gebied[row,]$intersect_area / overlap_intersection)
          # OPTIE 2: percentage van totale verspreiding dat in bepaald gebied valt
          #percentage_overlap_in = as.numeric(overlap_per_gebied[row,]$intersect_area / total_area)
          
          # percentage van oppervlakte HBTRL/VLRL/BWKHAB gebied dat overlapt met soortverspreiding
          percentage_overlap_of = as.numeric(overlap_per_gebied[row,]$intersect_area / overlap_per_gebied[row,]$geb_area)
        
          metrics_df <- data.frame(
            Soort = soort,
            Gebied = paste0(c("in", "of"), as.character(overlap_per_gebied[row,1])),
            Overlap = format(round(c(percentage_overlap_in, percentage_overlap_of), 3))
          )
        
          list.results[[i]] <- rbind(list.results[[i]], metrics_df)
        }
      }
      
    
      # occupancy metrics for PATDAT (i = 4)
      if (i == 4) {
        
        # totaal aantal domeinen waarmee verspreiding overlapt
        list.results[[i]] <- rbind(list.results[[i]], data.frame(
          Soort = soort,
          Gebied = "nDomeinen",
          Overlap = length(unique(occ_species_intersection$id))))
      
        # aantal bezette domeinen per type recht anb
        anb_rechten <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(id, rechtenanb, rechtenanb_abb) %>%
          unique() %>%
          group_by(rechtenanb_abb) %>%
          summarise(n = n()) 
      
        for (row in 1:nrow(anb_rechten)) {
          list.results[[i]] <- rbind(list.results[[i]], data.frame(
            Soort = soort,
            Gebied = paste0("n", as.character(anb_rechten[row,1])),
            Overlap = as.character(anb_rechten[row,2])))
        }
      
        # percentage overlap per anb regio
        overlap_per_anb_regio <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(regio_abb, intersect_area) %>%
          unique() %>%
          group_by(regio_abb) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          arrange() %>%
          inner_join(gebied_summary, by = c("regio_abb" = "code"))
      
        for (row in 1: nrow(overlap_per_anb_regio)) {
          # OPTIE 1: percentage van overlap met PATDAT per anb regio
          percentage_overlap_in = as.numeric(overlap_per_anb_regio[row,]$intersect_area / overlap_intersection)
          # OPTIE 2: percentage van totale verspreiding dat overlapt per anb regio
          #percentage_overlap_in = as.numeric(overlap_per_anb_regio[row,]$intersect_area / total_area)
          percentage_overlap_of = as.numeric(overlap_per_anb_regio[row,]$intersect_area / overlap_per_anb_regio[row,]$geb_area)
        
          metrics_df <- data.frame(
            Soort = soort,
            Gebied = paste0(c("in", "of"), as.character(overlap_per_anb_regio[row,1])),
            Overlap = format(round(c(percentage_overlap_in, percentage_overlap_of), 3))
          )
        
          list.results[[i]] <- rbind(list.results[[i]], metrics_df)
        }
      }
    
      # occupancy metrics for NBHP (i = 5)
      if (i == 5) {
        
        # totaal aantal gebieden waarmee verspreiding overlapt
        list.results[[i]] <- rbind(list.results[[i]], data.frame(
          Soort = soort,
          Gebied = "nNBHP",
          Overlap = length(unique(occ_species_intersection$id))))

        # aantal bezette domeinen per type natuurbeheerplan
        n_per_beheerplantype <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(id, natuurbeheerplantype, natuurbeheerplantype_abb) %>%
          unique() %>%
          group_by(natuurbeheerplantype_abb) %>%
          summarise(n = n())
      
        for (row in 1:nrow(n_per_beheerplantype)) {
          list.results[[i]] <- rbind(list.results[[i]], data.frame(
            Soort = soort,
            Gebied = paste0("n", as.character(n_per_beheerplantype[row,1])),
            Overlap = as.character(n_per_beheerplantype[row,2])))
        }
      
        # percentage overlap per eigendomtype
        overlap_per_eigendomtype <- occ_species_intersection %>%
          st_drop_geometry() %>%
          select(eigendomtype_abb, intersect_area) %>%
          unique() %>%
          group_by(eigendomtype_abb) %>%
          summarise(intersect_area = sum(intersect_area)) %>%
          arrange() %>%
          inner_join(gebied_summary, by = c("eigendomtype_abb" = "code"))
      
        for (row in 1: nrow(overlap_per_eigendomtype)) {
          # OPTIE 1: percentage van overlap met NBHP dat overlapt per eigendomtype
          percentage_overlap_in = as.numeric(overlap_per_eigendomtype[row,]$intersect_area / overlap_intersection)
          # OPTIE 2: percentage van totale verspreiding dat overlapt per eigendomtype
          #percentage_overlap_in = as.numeric(overlap_per_eigendomtype[row,]$intersect_area / total_area)
        
          list.results[[i]] <- rbind(list.results[[i]], data.frame(
            Soort = soort,
            Gebied = paste0("in", as.character(overlap_per_eigendomtype[row,1])),
            Overlap = format(round(percentage_overlap_in, 3))))
        } 
      }
      
      # Top 3 gebieden voor HBTRL, VGLRL, NBHP
      if (i %in% c(1,2,5)) {
          top_3 <- occ_species_intersection %>%
            group_by(naam = if (i == 2) gebnaam else if (i == 5) naamdossier else naam) %>%
            summarise(intersect_area = sum(intersect_area)) %>%
            slice_max(order_by = intersect_area, n = 3, na_rm = TRUE) %>%
            st_drop_geometry()
          
          for (row in 1:nrow(top_3)) {
            list.results[[6]] <- rbind(list.results[[6]], data.frame(
              Soort = soort,
              Gebied = paste0(names(list.dfs)[i], row),
              Overlap = as.character(top_3[row,1])))
        }
      }
      
      
      # Top 3 anb regio's en domeinen
      
      if (i == 4) {
        top_3_regio <- occ_species_intersection %>%
            group_by(regio) %>%
            summarise(intersect_area = sum(intersect_area)) %>%
            slice_max(order_by = intersect_area, n = 3, na_rm = TRUE) %>%
            st_drop_geometry()
        
        for (row in 1:nrow(top_3_regio)) {
            list.results[[6]] <- rbind(list.results[[6]], data.frame(
              Soort = soort,
              Gebied = paste0(names(list.dfs)[i], "regio", row),
              Overlap = as.character(top_3_regio[row,1])))
        }
        
        top_3_domein <- occ_species_intersection %>%
            group_by(domeinnaam) %>%
            summarise(intersect_area = sum(intersect_area)) %>%
            slice_max(order_by = intersect_area, n = 3, na_rm = TRUE) %>%
            st_drop_geometry()
        
        for (row in 1:nrow(top_3_domein)) {
            list.results[[6]] <- rbind(list.results[[6]], data.frame(
              Soort = soort,
              Gebied = paste0(names(list.dfs)[i], "domein", row),
              Overlap = as.character(top_3_domein[row,1])))
        }
      }
    }
    
    else {  # create empty row if there's no overlap 
      metrics_df <- data.frame(
        Soort = soort,
        Gebied = paste0(c("in", "of"), names(list.dfs)[i]),
        Overlap = 0)
      
      list.results[[i]] <- rbind(list.results[[i]], metrics_df)
    }
  }    
}
```

# Adjust column format from long to wide
```{r column-format-long-to-wide}
HBTRL <- list.results$HBTRL %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, contains("in"), contains("of"))

VGLRL <- list.results$VGLRL %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, contains("in"), contains("of"))

BWKHAB <- list.results$BWKHAB %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, contains("in"), contains("of"))

PATDAT <- list.results$PATDAT %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, starts_with("n"), starts_with("in"), starts_with("of"))

NBHP <- list.results$NBHP %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "0") %>%
  select(Soort, starts_with("n"), starts_with("in"))

TOP3 <- list.results$TOP3 %>%
  pivot_wider(names_from = Gebied, values_from = Overlap, values_fill = "-")
```

```{r save-list-results-as-RData-file}
saveRDS(list.results, file="./radius/data/output/list_results.RData")
```

```{r save-separate-dfs-as-csv}
write_csv(HBTRL, "./radius/data/output/HBTRL.csv")
write_csv(VGLRL, "./radius/data/output/VGLRL.csv")
write_csv(BWKHAB, "./radius/data/output/BWKHAB.csv")
write_csv(PATDAT, "./radius/data/output/PATDAT.csv")
write_csv(NBHP, "./radius/data/output/NBHP.csv")
write_csv(TOP3, "./radius/data/output/TOP3.csv")
```

